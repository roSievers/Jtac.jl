
abstract type Msg{S <: JtacService, D <: JtacService} end

# Sending an receiving messages. Note that receive is not safe, as it allows
# arbitrary code execution. So it must only be used on messages from trusted
# sources.
"""
    send(socket, message)

Sending a Jtac service message to socket.
"""
send(socket, msg :: Msg) = Serialization.serialize(socket, msg)

"""
    receive(socket)

Receiving a Jtac service message from socket.
"""
receive(socket) :: Msg = Serialization.deserialize(socket)


#
# Messages play -> train
#

"""
Login request of a play service.

This must be the initial message to a train service. The train service then
decides whether to accept the connection or not.
"""
struct PlayLogin <: Msg{Play, Train}
  token   :: String
  name    :: String
  version :: Int

  accept_data_requests    :: Bool
  accept_contest_requests :: Bool

  function PlayLogin(; token, name, data = true, contest = true)
    new(token, name, JTAC_SERVICE_VERSION, data, contest)
  end
end

"""
Logout message of a play service
"""
struct PlayLogout <: Msg{Play, Train}
  text :: String
end

"""
Record of training data generated by the play service.

It contains the compressed datasets and the id of the data request put by
the connected train service.
"""
struct DataRecord <: Msg{Play, Train}
  _data  :: Vector{UInt8} # compressed Jtac datasets
  reqid  :: Int
  id     :: Int
  dtime  :: Float64
end

"""
Record of contest data generated by the play service.

It contains the contest results and the id of the contest request put by the
connected train service.
"""
struct ContestRecord <: Msg{Play, Train}
  data   :: Array{Int, 3}
  reqid  :: Int
  id     :: Int
  dtime  :: Float64
end

#
# Messages watch -> train
#

"""
Login request of a watch service.

This must be the initial message to a train service. The train service then
decides whether to accept the connection or not.
"""
struct WatchLogin <: Msg{Watch, Train}
  token :: String
  version :: Int

  WatchLogin(; token) = new(token, JTAC_SERVICE_VERSION)
end

#
# Messages train -> watch
#

"""
Answer to the login request from a play service. If the request is not accepted,
the connection is closed.
"""
struct PlayAccept <: Msg{Train, Play}
  accept :: Bool
  text :: String
end

"""
Asking a play service to disconnect.
"""
struct PlayDisconnect <: Msg{Train, Play}
  text :: String
end

"""
Asking a play service to reconnect.
"""
struct PlayReconnect <: Msg{Train, Play}
  text :: String
  time :: Float64 # seconds before the reconnection should be attempted
end

"""
Asking a play service to discard the current data request.
"""
struct Idle <: Msg{Train, Play}
  text :: String
end

"""
Requesting the generation of training data from a play service.
"""
struct DataRequest <: Msg{Train, Play}

  spec :: PlayerSpec

  # Training options
  prepare_steps :: Tuple{Int, Int}
  branch_prob   :: Float64
  branch_steps  :: Tuple{Int, Int}
  augment       :: Bool

  # Dataset options
  min_playings  :: Int
  max_playings  :: Int

  # Hash of the instruction set
  id            :: Int

  function DataRequest( id :: Int
                      , player :: MCTSPlayer{G}
                      ; augment = true
                      , prepare_steps = 0
                      , branch_prob = 0.
                      , branch_steps = 1
                      , min_playings = 1
                      , max_playings = 10000
                      ) where {G <: Game}

    @assert !isabstracttype(G)

    new( PlayerSpec(player)
       , Jtac.tup(prepare_steps)
       , branch_prob
       , Jtac.tup(branch_steps)
       , augment
       , min_playings
       , max_playings
       , id )

  end

end


"""
Confirmation from the train service that the upload of a data record was
successful.
"""
struct DataConfirmation <: Msg{Train, Play}
  id :: Int
end

"""
Requesting the generation of contest data from a play service.
"""
struct ContestRequest <: Msg{Train, Play}

  specs  :: Vector{PlayerSpec}
  active :: Vector{Int} 
  length :: Int
  id     :: Int

end

function ContestRequest( id :: Int
                       , players :: Vector{<: MCTSPlayer}
                       , length :: Int
                       , active = 1:length(players) )

  # Make sure that a concrete, consistent game type can be derived
  Jtac.derive_gametype(players)

  specs = PlayerSpec.(players)
  ContestRequest(specs, active, length, id)

end


"""
Confirmation from the train service that the upload of a contest record was
successful.
"""
struct ContestConfirmation <: Msg{Train, Play}
  id :: Int
end

#
# Messages control -> train
#

struct UpdateContext <: Msg{Control, Train}
end

struct BackupModel <: Msg{Control, Train}
end

struct ConductContest <: Msg{Control, Train}
end

